# 架构选项

## 背景分析

**“完全异步”**，即逻辑和渲染以完全独立的、不可预测的步调运行，虽然在理论上提供了极致的解耦，但在实践中会带来巨大的复杂性，尤其是：

1. 不确定性 (Non-Determinism): 游戏逻辑的更新频率变得不可预测，这对于物理模拟、AI决策、网络同步等需要稳定时间步长的事情来说是致命的。物理效果会因为帧率的变化而变得不稳定。
2. 状态撕裂 (State Tearing): 当渲染线程和逻辑线程完全异步时，渲染线程极有可能在逻辑线程“写到一半”的时候去读取状态，导致渲染出部分更新、部分未更新的“撕裂”画面。这需要极其复杂的同步机制（如三缓冲、版本号）来解决，得不偿失。

## 圣杯架构——固定逻辑更新+插值渲染

如果游戏运行得很快（例如渲染帧240FPS），那么在多数渲染帧里，这个while循环可能一次都不执行。如果游戏运行得很慢（例如30FPS），那么在一次渲染帧里，这个while循环可能会执行两到三次，以“追赶”上真实流逝的时间。保证 **无论渲染帧率如何，游戏世界的演进速度是恒定的**。

1. 输入安全: 输入事件在逻辑更新开始前被一次性“快照”进队列。在整个逻辑更新循环中，这个队列只被读取，不会有新的输入进来。这解决了并发问题。
2. 逻辑确定性: 物理和游戏逻辑总是在固定的时间步长上运行，保证了稳定性和可预测性。
3. 渲染流畅性: 即使逻辑只以62.5Hz更新，插值技术也能让玩家在120Hz甚至更高刷新率的显示器上看到丝般顺滑的动画。

### 输入收集 (Input Gathering)

在每一“逻辑帧”的最开始，引擎会从主线程一次性地收集所有待处理的输入事件。这些事件被放入一个队列中。这个阶段非常快。

### 逻辑更新 (Fixed Update / Tick) 

1. 引擎有一个固定的时间步长，逻辑帧62.5Hz (16ms)。
2. 引擎内部有一个 **“时间累加器”** 。引擎都会把 **真实的物理时间** 累加并检查累加器：`while (accumulator >= fixed_timestep)` 
3. 如果累加器里的时间够`“一个逻辑步长”`，引擎就执行`“一次完整的逻辑更新”`（物理、AI、处理输入事件队列）；然后从累加器中减去一个fixed_timestep。

### 渲染 (Variable Update / Render)

1. 逻辑更新循环结束后，渲染线程开始工作。它以设备支持的最高帧率rAF运行。
2. 关键的魔法——**插值 (Interpolation)**: 渲染线程并不直接渲染刚刚计算出的最新逻辑状态。它会同时持有**上一个逻辑帧的状态** 和 **当前逻辑帧的状态**。然后，它会查看时间累加器里还剩下多少时间（例如，alpha = accumulator / fixed_timestep），这个alpha值（在0.0到1.0之间）代表了当前时间点在两个逻辑帧之间的位置。因为下一次逻辑更新可能要等好几毫秒。如果直接渲染，物体在屏幕上的移动就会是阶梯状的、不平滑的（每16ms跳一下）。注意：这种情况是 `渲染帧 > 逻辑帧`, 开启插值才是有用的。
