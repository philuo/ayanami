# 用户输入设计

## 输入事件相关问题

### 丢失问题

假设逻辑帧60Hz，平均每帧16.67ms，玩家手速快，可能在一帧内完成一次“按下”和“弹起”操作。(例如FPS游戏中快速点射子弹)

```
t = 0ms：逻辑帧开始读取对应按键的位掩码鼠标左键为0(弹起)
t = 5ms：玩家按下鼠标，主线程将鼠标左键位掩码置为1(按下)
t = 12ms：玩家松开鼠标，左键弹起，主线程将对应掩码置0(弹起)
t = 16ms：下一逻辑帧开始，读取鼠标左键位掩码发现仍然为0(弹起)
```

玩家按键丢失的场景！

### 顺序问题

在格斗游戏中，`“下” -> “前” -> “拳”` 是一个连招，在某一帧这三个键都按下了，如果只是位掩码是无法得知`“连招”`成立的。

### 上下文问题

当用户处在不同操作场景下，按键表达含义不同。在输入框按键就是打字，如果用户打开背包面板 / 选中技能面板按键表达的含义不同。

### 输入量问题

- 鼠标移动多少？
- 手柄推了多远？
- 滚轮滚动多少？

类似以上非简单的 `on / off` 状态，而是具有数值的量，无法使用单个bit位置的0/1进行表达。

## 事件队列

健壮的输入系统必须是`状态`和`事件`的结合。

### 环形缓冲区

事件队列(Event Queue)是保证不丢失和顺序的基石。在SAB上实现环形缓冲区(Ring Buffer)。**保证队列足够大就不会有事件处理不及时而被覆盖。**

1. 主线程作为“事件采集器”，它监听浏览器抛出的所有原始输入事件(keydown、keyup、mousedown、mouseup、mousemove、wheel、gamepadconnected、gamepaddisconnected等)

2. 每当一个事件发生，主线程就把它**序列化**成一个标准格式的数据包，并推入环形缓冲区的队尾。
`[event_time, event_code]`, 主线程只管往里塞，从不关心这些事件被如何处理。
