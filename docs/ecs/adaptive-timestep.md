# 自适应逻辑步长系统

## ⚠️ 适用范围

**本系统仅适用于单机游戏！**

网络游戏请参考：[网游模式时间步长策略](./online-mode-timestep.md)

## 概述

自适应步长系统根据设备性能和 rAF 稳定性，自动调整逻辑更新频率（30Hz ~ 62.5Hz），确保最佳性能和流畅度。

## 工作原理

### 三个阶段

```
启动阶段 (0-2秒)
├─ 使用保守的 50Hz (20ms)
├─ 收集 rAF 间隔数据
└─ 不做任何调整

校准阶段 (2-5秒)
├─ 收集 120 个样本
├─ 分析 rAF 稳定性
└─ 选择最佳步长

运行阶段 (5秒后)
├─ 持续监控性能
├─ 必要时升频/降频
└─ 10秒冷却期避免频繁切换
```

### 步长预设

| 档位 | 步长 | 频率 | 适用场景 | 目标 rAF 范围 |
|------|------|------|----------|---------------|
| 高性能 | 16ms | 62.5Hz | 120Hz+ 显示器，性能充足 | 6-12ms |
| 标准 | 20ms | 50Hz | 60Hz 显示器，标准性能 | 12-20ms |
| 节能 | 25ms | 40Hz | 低端设备，省电模式 | 20-28ms |
| 保守 | 33ms | 30Hz | 极低端设备，后台运行 | 28-50ms |

### 调整策略

#### 升频条件（全部满足）

```typescript
1. rAF 平均间隔 < 当前步长的目标范围下限
   例如: 当前 50Hz (20ms)，rAF 平均 < 12ms
   
2. rAF 稳定（变异系数 < 25%）
   变异系数 = 标准差 / 平均值
   
3. 逻辑计算有余量（< 步长的 60%）
   例如: 20ms 步长，逻辑平均 < 12ms
   
4. 不在最高档（62.5Hz）
```

#### 降频条件（任一满足）

```typescript
1. rAF 平均间隔 > 当前步长的目标范围上限
   例如: 当前 50Hz (20ms)，rAF 平均 > 20ms
   
2. rAF 不稳定（变异系数 > 37.5%）

3. 逻辑计算吃紧（> 步长的 85%）
   例如: 20ms 步长，逻辑平均 > 17ms
   
4. 不在最低档（30Hz）
```

### 保护机制

```typescript
// 1. 最大更新次数限制
const MAX_LOGIC_UPDATES = 3;

// 防止单帧内连续执行过多次逻辑更新
// 例如: rAF 突然延迟 60ms，最多执行 3 次逻辑

// 2. 累加器重置
if (updates >= MAX_LOGIC_UPDATES && acc >= LOGIC_STEP) {
  acc = 0; // 宁可慢动作，不要死亡螺旋
}

// 3. 调整冷却期
// 每次调整后 10 秒内不再调整
// 避免频繁切换导致的抖动
```

## 使用示例

### 基本使用

系统已自动集成到游戏循环，无需手动配置：

```typescript
// 启动时自动使用保守策略 (50Hz)
// 2秒后开始校准
// 5秒后完成校准并切换到最佳步长
// 运行时持续监控和优化
```

### 调试监控

开发模式下，每 5 秒自动输出状态：

```javascript
📊 自适应步长状态: {
  phase: 'calibrated',
  current: '高性能 (62.5Hz)',
  step: 16,
  hz: 62.5,
  raf: {
    avg: '8.23',
    stability: '89.2%',
    samples: 120
  },
  logic: {
    avg: '9.45',
    usage: '59.1%',
    samples: 120
  }
}
```

### 手动查询

在浏览器控制台：

```javascript
// 查看当前状态
__adaptive__.get_debug_info()

// 获取当前步长
__adaptive__.get_step()  // 16

// 获取当前频率
__adaptive__.get_hz()    // 62.5
```

## 实际场景示例

### 场景 1: 高性能 PC + 144Hz 显示器

```
启动 (0-2s):
  步长: 20ms (50Hz)
  rAF: ~6.9ms (144Hz)
  逻辑: ~10ms

校准 (2-5s):
  收集 120 个样本
  分析: rAF 平均 6.9ms，稳定性 92%
  决策: 升级到 16ms (62.5Hz) ✅

运行 (5s+):
  步长: 16ms (62.5Hz)
  rAF: ~6.9ms
  逻辑: ~10ms (62.5% 使用率)
  体验: 优秀，充分利用高刷新率 ✨
```

### 场景 2: 普通笔记本 + 60Hz 显示器

```
启动 (0-2s):
  步长: 20ms (50Hz)
  rAF: ~17ms (60Hz)
  逻辑: ~12ms

校准 (2-5s):
  收集 120 个样本
  分析: rAF 平均 17ms，稳定性 85%
  决策: 保持 20ms (50Hz) ✅

运行 (5s+):
  步长: 20ms (50Hz)
  rAF: ~17ms
  逻辑: ~12ms (60% 使用率)
  体验: 流畅，标准配置 👍
```

### 场景 3: 低端设备 + rAF 不稳定

```
启动 (0-2s):
  步长: 20ms (50Hz)
  rAF: 12-35ms（波动大）
  逻辑: ~18ms

校准 (2-5s):
  收集 120 个样本
  分析: rAF 平均 22ms，稳定性 52% ⚠️
  决策: 降级到 25ms (40Hz) ⬇️

运行 (5s+):
  步长: 25ms (40Hz)
  rAF: ~22ms
  逻辑: ~18ms (72% 使用率)
  体验: 良好，避免了卡顿 ✅
```

### 场景 4: 运行时性能下降

```
正常运行 (0-60s):
  步长: 16ms (62.5Hz)
  逻辑: ~10ms
  
性能下降 (60s+):
  - CPU 温度升高
  - 后台进程启动
  - rAF 变慢到 15-25ms
  - 逻辑变慢到 14ms
  
系统响应:
  检测到: rAF 不稳定，逻辑占用 87.5% ⚠️
  决策: 降级到 20ms (50Hz) ⬇️
  结果: 性能恢复稳定 ✅
  
性能恢复 (120s+):
  - CPU 冷却
  - 后台进程结束
  - rAF 恢复到 8-12ms
  - 逻辑恢复到 10ms
  
系统响应:
  检测到: rAF 快速且稳定，逻辑占用 50% ✅
  决策: 升级回 16ms (62.5Hz) ⬆️
  结果: 充分利用性能 ✨
```

## 性能影响

### CPU 开销

```
监控逻辑: < 0.1ms/帧
数据收集: < 0.05ms/帧
统计分析: ~2ms (每 120 帧一次)
总开销: 可忽略不计 ✅
```

### 内存开销

```
rAF 历史: 120 个 f64 = 960 字节
逻辑历史: 120 个 f64 = 960 字节
配置数据: < 1KB
总开销: ~3KB ✅
```

## 配置选项

如果需要自定义，可以修改 `adaptive.ts`：

```typescript
private config = {
  /** 收集样本数量 */
  sample_size: 120,           // 默认 120 帧 (约 2 秒)
  
  /** 启动保守期（秒） */
  startup_duration: 2,        // 默认 2 秒
  
  /** 校准期（秒） */
  calibration_duration: 5,    // 默认 5 秒
  
  /** 调整冷却时间（秒） */
  adjustment_cooldown: 10,    // 默认 10 秒
  
  /** 稳定性阈值（变异系数） */
  stability_threshold: 0.25,  // 默认 25%
};
```

## 与手动配置对比

### 手动固定步长

```typescript
// configs/index.ts
game: {
  logic_frame_step: 16  // 固定 62.5Hz
}

优点:
✅ 简单直接
✅ 可预测

缺点:
❌ 低端设备可能卡顿
❌ 高端设备未充分利用
❌ rAF 不稳定时表现差
```

### 自适应步长

```typescript
// 自动管理
const adaptive = new AdaptiveTimestep(true);

优点:
✅ 适应各种设备
✅ 应对 rAF 波动
✅ 运行时动态优化
✅ 自动降级保护

缺点:
⚠️ 稍微复杂
⚠️ 需要校准时间
```

## 最佳实践

1. **启动时使用保守策略**
   ```typescript
   new AdaptiveTimestep(true)  // ✅ 推荐
   ```

2. **给予充足的校准时间**
   ```typescript
   // 至少 5 秒后再做性能评估
   // 初期数据不够稳定
   ```

3. **监控调试输出**
   ```typescript
   // 开发时观察步长切换
   // 确保符合预期
   ```

4. **关注极端情况**
   ```typescript
   // 测试低端设备
   // 测试后台标签页
   // 测试高负载场景
   ```

## 故障排查

### 问题: 频繁切换步长

```
现象: 每隔几秒就在 50Hz 和 62.5Hz 之间切换

原因: 性能处于临界点

解决:
1. 检查 stability_threshold（可能设置太低）
2. 增加 adjustment_cooldown
3. 优化逻辑性能，远离临界点
```

### 问题: 从不升频

```
现象: 一直保持 50Hz，即使设备性能很好

原因: 逻辑耗时过高

解决:
1. 检查逻辑平均耗时
2. 必须 < 当前步长的 60% 才会升频
3. 优化逻辑算法
```

### 问题: 步长选择不合理

```
现象: 60Hz 显示器选择了 62.5Hz

原因: rAF 测量不准确

解决:
1. 增加 sample_size (如 180)
2. 延长 startup_duration (如 3s)
3. 检查是否有其他程序干扰
```

## 总结

自适应步长系统是 Web 游戏的**最佳实践**：

- ✅ **智能**: 自动适应设备性能
- ✅ **稳定**: 应对 rAF 波动
- ✅ **安全**: 多重保护机制
- ✅ **高效**: 开销可忽略
- ✅ **灵活**: 可配置可监控

推荐所有 Web 游戏项目使用！🚀

